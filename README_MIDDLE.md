<div style = "font-family: 'Open Sans', sans-serif; font-size: 16px">

# ClassMiddleSensor
<div style = "color: #555">
    <p align="center">
    <img src="./res/logo.png" width="400" title="hover text">
    </p>
</div>

## Описание
<div style = "color: #555">

Является ключевой составляющей [рассматриваемой архитектуры классов](./README.md). Смысл данного класса заключается в унификации работы с датчиками и их каналами, обеспечивая легкость и надежность взаимодействия прикладных разработчиков с датчиками в рамках фрейморка EcoLight. Наследуется от **ClassAncestorSensor**.
Реализует важнейшие принципы **ModuleSensor**:
- Унификация хранения значений: **ClassMiddleSensor** организует хранение считанных значений с датчика в виде аксессоров (*Ch0_Value*, *Ch1_Value* и тд.), которые ссылаются на кольцевой буффер, созданный под каждый канал. Это обеспечивает единый интерфейс для работы с различными датчиками и их каналами.
- Обработка данных через аксессоры: упомянутые выше аксессоры служат единой прослойкой, через которую проходят данные, позволяя применять ограничительные функции, трансформирующую линейную функцию, фильтрацию и проверку на нахождение в заданных зонах измерения. Это обеспечивает надежную и легко расширяемую обработку данных с датчика (см. подробнее в [ClassDataRefine](./README_DATA_REFINE.md#обработка-значений-с-датчика)).
- Автоматическое создание каналов: при инициализации "реального" датчика класс **ClassMiddleSensor** автоматически создает объекты-каналы (см. [ClassChannel](./README_CHANNEL.md)), которые композируются в поле этого класса. Это упрощает создание и управление каналами датчика.
- Определение сигнатур методов: класс **ClassMiddleSensor** определяет сигнатуры основных методов, которые будут доступны для работы с "реальными" датчиками и их каналами. Это обеспечивает единый интерфейс для инициализации, запуска, настройки и управления датчиками.
</div>

### Поля
<div style = "color: #555">

- <mark style="background-color: lightblue">_Values</mark> - массив с объектами, реализующими кольцевой буффер;
- <mark style="background-color: lightblue">_Channels</mark> - массив с автоматически инстанцирующимися объектами ClassChannel;
- <mark style="background-color: lightblue">_IsChUsed</mark> - массив булевых значений, в котором i-й элемент указывает запущен ли в данный момент опрос i-го канала.
</div>

### Аксессоры
<div style = "color: #555">

- <mark style="background-color: lightblue">Ch*N*_Value</mark> - геттер/сеттер в который **необходимо** записывать полученные с датчика необработанные значения  и с него же далее необходимо их считывать. В этом сеттере "сырое" значение автоматически проходит через все этапы обработки, включая фильтр (см. диаграмму "Обработка значений с датчика" ниже);
- <mark style="background-color: lightblue">CountChannels</mark> - геттер, возвращающий количество корректно инициализированных каналов типа **ClassChannel**.
</div>

### Методы
<div style = "color: #555">

- <mark style="background-color: lightblue">InitСhannels(_sensor_props)</mark> - инициализирует необходимые для его работы аксессоры и создает объекты каналов;
- <mark style="background-color: lightblue">Init(_opts)</mark> - обязывает провести инициализацию датчика настройкой необходимых для его работы регистров;
- <mark style="background-color: lightblue">ConfigureRegs(_opts)</mark> - обязывает выполнить дополнительную конфигурацию датчика. Это может быть настройка пина прерывания, периодов измерения и прочих шагов, которые в общем случае необходимы для работы датчика, но могут переопределяться в процессе работы, и потому вынесены из метода Init();
- <mark style="background-color: lightblue">GetChannel(_ch_num)</mark> - возвращает объект i-го канала;

- <mark style="background-color: lightblue">Start(_ch_num, [_period], [_opts])</mark> - обязывает запустить циклический опрос определенного канала датчика с заданной периодичностью в мс. Переданное значение периода должно сверяться с минимальным значением для данного канала и, если требуется, регулироваться, так как максимальная частота опроса зависит от характеристик датичка. 
В некоторых датчиках считывание значений с нескольких каналов происходит неразрывно и одновременно. В таких случаях ведется только один циклический опрос, а повторный вызов метода Start() для конкретного канала лишь определяет, будет ли в процессе опроса обновляться значение данного канала;
- <mark style="background-color: lightblue">Stop(_ch_num)</mark> - обязывает прекратить считывание значений с заданного канала. В случаях, когда значения данного канала считываются синхронно с другими, достаточно прекратить обновление данных;
- <mark style="background-color: lightblue">ChangeFreq(_ch_num, _period)</mark> - обязывает останавливить опрос указанного канала и запустить его вновь с уже новой частотой. Возобновиться должно обновление всех каналов, которые опрашивались перед остановкой;
- <mark style="background-color: lightblue">Run(_ch_num, [_opts])</mark> - обязывает запустить прикладную работу датчика, сперва выполнив его полную инициализацию, конфигурацию и прочие необходимые процедуры, обеспечив его безопасный и корректный запуск;
- <mark style="background-color: lightblue">Reset()</mark> - обязывает выполнить перезагрузку датчика;
- <mark style="background-color: lightblue">SetRepeatability(_rep)</mark> - обязывает устанавить значение повторяемости
- <mark style="background-color: lightblue">SetPrecision(_pres)</mark> - обязывает устанавливить точность измерений;
- <mark style="background-color: lightblue">Read(_reg)</mark> - обязывает реализовать чтение с регистра;
- <mark style="background-color: lightblue">Write(_reg, _val)</mark> - обязывает реализовать запись в регистр.
</div>

</div>