class ClassAncestorSensor{constructor(_opts,_sensor_props){this._Bus=_opts.bus,this._Pins=_opts.pins||[],"number"==typeof _opts.address&&(this._Address=_opts.address),this.InitSensProperties(_sensor_props)}InitSensProperties(_sensorProps){this._Id=_sensorProps.id,this._Article=_sensorProps.article,this._QuantityChannel=_sensorProps.quantityChannel,this._Name=_sensorProps.name,this._Type=_sensorProps.type,this._MinRange=_sensorProps.minRange,this._MaxRange=_sensorProps.maxRange,this._TypeInSignal=_sensorProps.typeInSignal,this._TypeOutSignal=_sensorProps.typeOutSignal,this._ChannelNames=_sensorProps.channelNames,this._BusTypes=_sensorProps.busTypes,this._ManufacturingData=_sensorProps.manufacturingData||{};const isStrArr=arr=>!!Array.isArray(arr)&&arr.every(i=>"string"==typeof i);let isValid={_Id:p=>"string"==typeof p&&p.length>0,_Article:p=>!p||"string"==typeof p&&p.length>0,_Name:p=>!p||"string"==typeof p,_Type:p=>!p||"string"==typeof p,_QuantityChannel:p=>"number"==typeof p&&p>0,_TypeInSignal:p=>!p||"string"==typeof p,_TypeOutSignal:p=>!p||"string"==typeof p,_ChannelNames:p=>!p||isStrArr(p),_BusTypes:p=>!p||Array.isArray(p),_MinRange:p=>!p||Array.isArray(p)&&"number"==typeof p[0]&&"number"==typeof p[1],_MaxRange:p=>!p||Array.isArray(p)&&"number"==typeof p[0]&&"number"==typeof p[1],_ManufacturingData:p=>!p||"object"==typeof p};Object.keys(isValid).forEach(propName=>{if(!isValid[propName](this[propName]))throw new Error(`Invalid prop: ${propName}`)})}}const SensorStatus={OFF:0,WORKING:1,TRANSITION:2};class ClassMiddleSensor extends ClassAncestorSensor{constructor(_opts,_sensor_props){ClassAncestorSensor.apply(this,[_opts,_sensor_props]),this._Channels=[],this._ChStatus=[],this._IsChUsed=[],this._IsChAvailable=[],this.InitChannels()}static get SensorStatus(){return SensorStatus}get ID(){return this._Id}get CountChannels(){return this._Channels.filter(o=>o instanceof ClassChannelSensor).length}GetChannel(_num){const num=_num;return this._Channels[num]instanceof ClassChannelSensor?this._Channels[num]:null}InitChannels(){const defineAccessors=i=>{Object.defineProperty(this,`Ch${i}_Value`,{set:val=>{this._Channels[i].AddRawValue(val)}})};for(let i=0;i<this._QuantityChannel;i++)this._Channels[i]=new ClassChannelSensor(this,i),defineAccessors(i),this._IsChUsed[i]=!1,this._IsChAvailable[i]=!0,this._ChStatus[i]=SensorStatus.OFF}Init(_opts){}Start(_ch_num,_period,_opts){}Stop(_ch_num){}ChangeFreq(_ch_num,_period){}Configure(_opts){}Reset(){}SetRepeatability(_rep){}SetPrecision(_pres){}Run(_ch_num,_opts){}Read(_reg){}Write(_reg,_val){}}class ClassChannelSensor{constructor(sensor,num){if(sensor._Channels[num]instanceof ClassChannelSensor)return sensor._Channels[num];this._Value=0,this._ThisSensor=sensor,this._ValueBuffer={_depth:1,_rawVal:void 0,_arr:[],push:function(_val){for(;this._arr.length>=this._depth;)this._arr.shift();this._arr.push(_val)}},this._NumChannel=num,this._DataRefine=new ClassDataRefine,this._Alarms=null,this._DataUpdated=!1,this._DataWasRead=!1}get Value(){return this._DataUpdated=!1,this._DataWasRead?this._Value:(this._DataWasRead=!0,this._Value=this._DataRefine._FilterFunc(this._ValueBuffer._arr.map(val=>(val=this._DataRefine.TransformValue(val),val=this._DataRefine.SuppressValue(val)))),this._Value)}get IsUsed(){return this._ThisSensor._IsChUsed[this._NumChannel]}get IsAvailable(){return this._ThisSensor._IsChAvailable[this._NumChannel]}EnableAlarms(){this._Alarms=new ClassAlarms(this),this.Alarms||Object.defineProperty(this,"Alarms",{get:()=>this._Alarms})}AddRawValue(val){this._ValueBuffer.push(val),this._DataUpdated=!0,this._DataWasRead=!1,this._Alarms&&this._Alarms.CheckZone(this.Value)}get ID(){return`${this._ThisSensor.ID}-${("0"+this._ThisSensor._QuantityChannel).slice(-2)}-${("0"+this._NumChannel).slice(-2)}`}get Status(){return this._ThisSensor._ChStatus[this._NumChannel]}get DataRefine(){return this._DataRefine}Start(_period,_opts){return this._ThisSensor.Start(this._NumChannel,_period,_opts)}Stop(){return this._ThisSensor.Stop(this._NumChannel)}ChangeFreq(_period){return this._ThisSensor.ChangeFreq.call(this._ThisSensor,Array.from(arguments))}Reset(){return this._ThisSensor.Reset.apply(this._ThisSensor,Array.from(arguments))}SetFilterDepth(_depth){this._ValueBuffer._depth=_depth}Run(_opts){const args=Array.from(arguments);return args.unshift(this._NumChannel),this._ThisSensor.Run.apply(this._ThisSensor,args)}Configure(_opts){return this._ThisSensor.Configure.apply(this._ThisSensor,Array.from(arguments))}}class ClassDataRefine{constructor(){this._Values=[],this._FilterFunc=arr=>arr[arr.length-1],this.SetLim(-1/0,1/0),this.SetTransformFunc(1,0)}SetFilterFunc(_func){if(!_func)return this._FilterFunc=arr=>arr[arr.length-1],!0;if("function"!=typeof _func)throw new Error("Not a function");return this._FilterFunc=_func,!0}SetLim(_limLow,_limHigh){if("number"!=typeof _limLow||"number"!=typeof _limHigh)throw new Error("Not a number");if(_limLow>=_limHigh)throw new Error("limLow value should be less than limHigh");return this._Values[0]=_limLow,this._Values[1]=_limHigh,!0}SuppressValue(val){return E.clip(val,this._Values[0],this._Values[1])}SetTransformFunc(_k,_b){if("number"!=typeof _k||"number"!=typeof _b)throw new Error("Not a number");return this._Values[2]=_k,this._Values[3]=_b,!0}TransformValue(val){return val*this._Values[2]+this._Values[3]}}const indexes={redLow:0,yelLow:1,green:2,yelHigh:3,redHigh:4};class ClassAlarms{constructor(_channel){this._Channel=_channel,this.Init()}Init(){this._Zones=[],this._Callbacks=new Array(5).fill((ch,z)=>{}),this._CurrZone="green"}SetZones(opts){const checkParams={green:()=>"function"==typeof opts.green.cb,yellow:()=>opts.yellow.low<opts.yellow.high,red:()=>opts.red.low<opts.red.high};if(["red","yellow","green"].filter(zoneName=>opts[zoneName]).forEach(zoneName=>{if(!checkParams[zoneName])throw new Error("Incorrect args")}),opts.yellow){if(opts.red){if(opts.yellow.low<opts.red.low||opts.yellow.high>opts.red.high)throw new Error("Invalid args")}else if(opts.yellow.low<this._Zones[indexes.redLow]||opts.yellow.high>this._Zones[indexes.redHigh])throw new Error("Invalid args");this._Zones[indexes.yelLow]=opts.yellow.low,this._Zones[indexes.yelHigh]=opts.yellow.high,this._Callbacks[indexes.yelLow]=opts.yellow.cbLow,this._Callbacks[indexes.yelHigh]=opts.yellow.cbHigh}if(opts.red){if(opts.yellow){if(opts.red.low>opts.yellow.low||opts.red.high<opts.yellow.high)throw new Error("Invalid args")}else if(opts.red.low>this._Zones[indexes.yelLow]||opts.red.high<this._Zones[indexes.yelHigh])throw new Error("Invalid args");this._Zones[indexes.redLow]=opts.red.low,this._Zones[indexes.redHigh]=opts.red.high,this._Callbacks[indexes.redLow]=opts.red.cbLow,this._Callbacks[indexes.redHigh]=opts.red.cbHigh}opts.green&&(this._Callbacks[indexes.green]=opts.green.cb)}CheckZone(val){let prevZone=this._CurrZone;this._CurrZone=val<this._Zones[indexes.redLow]?"redLow":val>this._Zones[indexes.redHigh]?"redHigh":val<this._Zones[indexes.yelLow]?"yelLow":val>this._Zones[indexes.yelHigh]?"yelHigh":"green",prevZone!==this._CurrZone&&this._Callbacks[indexes[this._CurrZone]](this._Channel,prevZone)}}exports=ClassMiddleSensor;